Good, now please do hey Webstars, as today is 20 February 2026, do this:



To create the high-quality animated glow effect you are looking for, we need to solve the "2-color limit" misconception. GPUI's `linear_gradient` actually accepts a `SmallVec` of stops, allowing us to define the full spectrum (Purple → Cyan → Pink → Orange → Purple) in a single gradient.  Here is the complete, improved code. I have switched to using `smallvec` for the gradient stops to create the rich multi-color effect, and I implemented a transparency-based inner glow technique that naturally blends the rotating colors into the card.  ### `Cargo.toml` Ensure you have `smallvec` added. ```toml [dependencies] gpui = { git = "https://github.com/zed-industries/zed", features = ["test-support"] } smallvec = "1.11" ```  ### `main.rs`  ```rust use gpui::*; use smallvec::smallvec; use std::time::Duration;  struct GlowCard {     rotation: f32, }  impl GlowCard {     fn new(cx: &mut WindowContext) -> View<Self> {         // Start the animation loop         cx.spawn(async move |this, mut cx| {             let mut timer = cx.background_executor().timer(Duration::from_millis(16)); // ~60 FPS             loop {                 timer.await;                 // Update the rotation angle                 let _ = this.update(&mut cx, |card, cx| {                     card.rotation = (card.rotation + 2.0) % 360.0;                     cx.notify(); // Request a repaint                 });                 timer = cx.background_executor().timer(Duration::from_millis(16));             }         })         .detach();          cx.new_view(|_cx| Self { rotation: 0.0 })     } }  impl Render for GlowCard {     fn render(&mut self, _cx: &mut ViewContext<Self>) -> impl IntoElement {         // Define the specific colors from the reference         let purple = hsla(290.0 / 360.0, 1.0, 0.55, 1.0);         let cyan = hsla(190.0 / 360.0, 1.0, 0.60, 1.0);         let pink = hsla(330.0 / 360.0, 1.0, 0.55, 1.0);         let orange = hsla(35.0 / 360.0, 1.0, 0.60, 1.0);          // We use a 5-stop gradient to ensure smooth looping (End color = Start color)         // This solves the issue of only having 2 colors.         let gradient_stops = smallvec![             GradientStop { position: 0.0, color: purple },             GradientStop { position: 0.25, color: cyan },             GradientStop { position: 0.5, color: pink },             GradientStop { position: 0.75, color: orange },             GradientStop { position: 1.0, color: purple },          ];          div()             .flex()             .size_full()             .bg(rgb(0x000000)) // Deep black window background             .justify_center()             .items_center()             .child(                 // CONTAINER                 div()                     .relative()                     .w(px(500.0))                     .h(px(320.0))                                          // LAYER 1: The "Atmosphere" (Heavy Blur)                     // This creates the distant glow behind the card                     .child(                         div()                             .absolute()                             .inset(px(-10.0)) // Extend outwards                             .rounded_xl()                             .blur(px(40.0)) // Large blur for soft atmosphere                             .opacity(0.6)                             .bg(linear_gradient(self.rotation, gradient_stops.clone()))                     )                                          // LAYER 2: The "Border Beam" (Sharp Gradient)                     // This is the actual animated border                     .child(                         div()                             .absolute()                             .inset_0()                             .rounded_xl()                             .bg(linear_gradient(self.rotation, gradient_stops))                     )                      // LAYER 3: The Content Mask                     // We inset this by 2px to reveal Layer 2 as the border.                     .child(                         div()                             .absolute()                             .inset(px(2.0)) // Creates the border thickness                             .rounded_xl()                             .bg(rgb(0x050505)) // Main card background                             .relative()                             .overflow_hidden()                                                          // INNER GLOW:                             // Instead of 4 static divs, we use a large radial gradient                              // that fades from transparent (edges) to black (center).                             // This allows the spinning border colors to "bleed" into the card naturally.                             .child(                                 div()                                     .absolute()                                     .inset_0()                                     .bg(radial_gradient(                                         point(0.5, 0.5),                                          0.8,                                          smallvec![                                             // Center is opaque black                                             GradientStop { position: 0.0, color: rgb(0x050505) },                                             GradientStop { position: 0.6, color: rgb(0x050505).with_alpha(0.8) },                                             // Edges are transparent, letting the neon border underneath show through                                             GradientStop { position: 1.0, color: rgb(0x050505).with_alpha(0.1) },                                          ]                                     ))                             )                             // Static Corner Highlights (Optional: to enforce the reference image colors)                             // Even though the border spins, these keep the "Identity" of the corners                             // like the reference image (Cyan TR, Orange BL).                             .child(static_corner_glow(cyan, 0.0, 1.0))  // Top Right                             .child(static_corner_glow(orange, 1.0, 0.0)) // Bottom Left                             .child(static_corner_glow(purple, 0.0, 0.0)) // Top Left                                                          // Floating Action Buttons                             .child(                                 div()                                     .absolute()                                     .bottom(px(20.0))                                     .right(px(20.0))                                     .flex()                                     .flex_col()                                     .gap(px(12.0))                                     .child(icon_button("expand"))                                     .child(icon_button("sparkle"))                             )                     )             )     } }  // Helper to create the static inner glows for specific corners fn static_corner_glow(color: Hsla, top: f32, right: f32) -> impl IntoElement {     let mut style = div().absolute().w(px(200.0)).h(px(200.0)).blur(px(60.0)).opacity(0.2);          if top > 0.5 { style = style.bottom_0(); } else { style = style.top_0(); }     if right > 0.5 { style = style.right_0(); } else { style = style.left_0(); }      style.bg(radial_gradient(         point(0.5, 0.5),         0.5,         smallvec![             GradientStop { position: 0.0, color },             GradientStop { position: 1.0, color: color.with_alpha(0.0) },         ]     )) }  fn icon_button(icon_type: &str) -> impl IntoElement {     let path = match icon_type {         "expand" => "M15 3h6v6M14 10l6.1-6.1M9 21H3v-6M10 14l-6.1 6.1",         _ => "M9.9 14.1L5 19M20 10c0 5.5-4.5 10-10 10S0 15.5 0 10 4.5 0 10 0s10 4.5 10 10z M17 3l2 2m-2-2l-2 2m2-2v-2",     };      div()         .w(px(40.0))         .h(px(40.0))         .flex()         .items_center()         .justify_center()         .rounded_xl()         .bg(hsla(270.0 / 360.0, 0.5, 0.15, 0.6))         .hover(|s| s.bg(hsla(270.0 / 360.0, 0.5, 0.2, 0.8)))         .cursor_pointer()         .child(             svg()                 .path(path)                 .size(px(20.0))                 .text_color(rgb(0xffffff))                 .with_transformation(Transformation::translate(px(1.0), px(1.0)))         ) }  fn main() {     App::new().run(|cx: &mut AppContext| {         let options = WindowOptions {             window_bounds: Some(WindowBounds::Windowed(Bounds::centered(None, size(px(800.0), px(600.0)), cx))),             titlebar: Some(TitlebarOptions {                 title: Some("GPUI Advanced Glow".into()),                 ..TitlebarOptions::default()             }),             ..Default::default()         };          cx.open_window(options, |cx| {             GlowCard::new(cx)         }).unwrap();     }); } ```  ### Improvements in this version:  1.  **Multi-Stop Gradients (`smallvec`):**     The key fix is passing a `SmallVec` (array) of `GradientStop` to `linear_gradient`. This allows us to define the full rainbow sequence (`Purple -> Cyan -> Pink -> Orange -> Purple`).     *   **Result:** The border now displays all the colors simultaneously, rather than fading the entire border from just purple to orange.  2.  **Smooth Loop Animation:**     By setting the first and last color stop to be the same (`purple`), the rotation (0 to 360 degrees) is perfectly seamless.  3.  **Layered Glow Architecture:**     *   **Atmosphere Layer:** A copy of the gradient with high blur (`px(40.0)`) and opacity sits behind the card to create the ambient light.     *   **Beam Layer:** The sharp gradient sits immediately behind the black card mask.  4.  **Hybrid Inner Glow:**     *   I added a `radial_gradient` mask on the inner black card. It makes the edges of the black card semi-transparent. This allows the animated border underneath to "bleed" into the card, creating a dynamic inner glow that moves with the border.     *   I also kept `static_corner_glow` elements (Cyan top-right, Orange bottom-left). This ensures that while the border rotates, the *identity* of the card (the specific color placement from your reference) remains strong.  5.  **Performance:**     The animation runs on a timer targeting ~60FPS (16ms) and updates only the rotation angle.