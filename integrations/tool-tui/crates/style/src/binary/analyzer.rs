use regex::Regex;
/// Compile-Time Style Analyzer
///
/// Scans source files to detect commonly used style combinations
/// and generates optimized combo tables
use std::collections::HashMap;
use std::fs;
use std::path::Path;

#[derive(Debug, Clone)]
pub struct StylePattern {
    pub classes: Vec<String>,
    pub count: usize,
}

pub struct StyleAnalyzer {
    patterns: HashMap<String, usize>,
}

impl StyleAnalyzer {
    pub fn new() -> Self {
        Self {
            patterns: HashMap::new(),
        }
    }

    /// Scan a source file for class attribute patterns
    pub fn scan_file(&mut self, path: &Path) -> Result<(), Box<dyn std::error::Error>> {
        let content = fs::read_to_string(path)?;

        // Match class="..." and className="..." patterns
        let class_regex = Regex::new(r#"(?:class|className)=["']([^"']+)["']"#)?;

        for cap in class_regex.captures_iter(&content) {
            if let Some(classes_str) = cap.get(1) {
                let classes: Vec<&str> = classes_str.as_str().split_whitespace().collect();

                // Track 2-5 class combinations
                for window_size in 2..=5 {
                    if classes.len() >= window_size {
                        for window in classes.windows(window_size) {
                            let pattern = window.join(" ");
                            *self.patterns.entry(pattern).or_insert(0) += 1;
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Scan a directory recursively
    pub fn scan_directory(&mut self, dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
        if dir.is_dir() {
            for entry in fs::read_dir(dir)? {
                let entry = entry?;
                let path = entry.path();

                if path.is_dir() {
                    // Skip node_modules, target, etc.
                    if let Some(name) = path.file_name() {
                        let name = name.to_string_lossy();
                        if name == "node_modules" || name == "target" || name == ".git" {
                            continue;
                        }
                    }

                    self.scan_directory(&path)?;
                } else if path.is_file() {
                    // Process TSX, JSX, HTML files
                    if let Some(ext) = path.extension() {
                        let ext = ext.to_string_lossy();
                        if ext == "tsx"
                            || ext == "jsx"
                            || ext == "html"
                            || ext == "ts"
                            || ext == "js"
                        {
                            if let Err(e) = self.scan_file(&path) {
                                eprintln!("Warning: Failed to scan {}: {}", path.display(), e);
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Get the most common patterns
    pub fn get_top_patterns(&self, count: usize, min_occurrences: usize) -> Vec<StylePattern> {
        let mut patterns: Vec<_> = self
            .patterns
            .iter()
            .filter(|(_, count)| **count >= min_occurrences)
            .map(|(pattern, count)| StylePattern {
                classes: pattern.split_whitespace().map(String::from).collect(),
                count: *count,
            })
            .collect();

        patterns.sort_by(|a, b| b.count.cmp(&a.count));
        patterns.truncate(count);
        patterns
    }

    /// Generate Rust code for combo dictionary (Hybrid Mode)
    pub fn generate_combo_code(&self, top_n: usize, min_occurrences: usize) -> String {
        let patterns = self.get_top_patterns(top_n, min_occurrences);

        let mut code = String::new();
        code.push_str("// Auto-generated by style analyzer (Hybrid Engine)\n");
        code.push_str("// Frequency-based macro detection\n");
        code.push_str("// Patterns with >= {} uses are auto-grouped as macros\n\n");

        // Generate macro dictionary
        code.push_str("pub static AUTO_MACROS: &[(MacroId, &str, usize)] = &[\n");

        let mut macro_id = 10000u16;
        for pattern in &patterns {
            let combo = pattern.classes.join(" ");
            code.push_str(&format!(
                "    ({}, \"{}\", {}),  // Used {} times â†’ MACRO\n",
                macro_id,
                combo,
                pattern.classes.len(),
                pattern.count
            ));
            macro_id += 1;
        }

        code.push_str("];\n\n");

        // Generate pattern mapping
        code.push_str("// Pattern â†’ MacroID mapping\n");
        code.push_str("pub fn init_pattern_map() -> HashMap<Vec<StyleId>, MacroId> {\n");
        code.push_str("    let mut map = HashMap::new();\n");

        macro_id = 10000;
        for pattern in &patterns {
            code.push_str("    map.insert(vec![");
            code.push_str(&pattern.classes.join(", "));
            code.push_str(&format!("], {});\n", macro_id));
            macro_id += 1;
        }

        code.push_str("    map\n");
        code.push_str("}\n");

        code
    }

    /// Print analysis report (Hybrid Engine)
    pub fn print_report(&self, top_n: usize, min_occurrences: usize) {
        let patterns = self.get_top_patterns(top_n, min_occurrences);

        println!("=== HYBRID BINARY CSS ENGINE ===");
        println!("=== Frequency-Based Analysis ===\n");

        println!("Total unique patterns: {}", self.patterns.len());
        println!("Grouping threshold: {} uses", min_occurrences);
        println!("Top {} patterns (â‰¥{} occurrences):\n", top_n, min_occurrences);

        println!("â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
        println!("â”‚ ID  â”‚ Uses   â”‚ Pattern                                 â”‚ Strategy â”‚");
        println!("â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");

        let mut macro_id = 10000;
        for pattern in patterns.iter() {
            let pattern_str = pattern.classes.join(" + ");
            let strategy = if pattern.count >= min_occurrences {
                "MACRO"
            } else {
                "ATOMIC"
            };

            println!(
                "â”‚{:4} â”‚ {:>5}Ã— â”‚ {:<39} â”‚ {} â”‚",
                macro_id,
                pattern.count,
                if pattern_str.len() > 39 {
                    format!("{}...", &pattern_str[..36])
                } else {
                    pattern_str
                },
                strategy
            );
            macro_id += 1;
        }

        println!("â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");

        // Calculate savings
        let total_individual_ids: usize = patterns.iter().map(|p| p.classes.len() * p.count).sum();
        let total_macro_ids: usize =
            patterns.len() * patterns.iter().map(|p| p.count).sum::<usize>();
        let bytes_saved = (total_individual_ids * 2) - (total_macro_ids * 2);

        println!("ðŸ“Š OPTIMIZATION IMPACT:");
        println!("  â†’ Macro entries: {}", patterns.len());
        println!("  â†’ Individual IDs: {} â†’ Macro IDs: {}", total_individual_ids, total_macro_ids);
        println!(
            "  â†’ Bytes saved: {} bytes ({:.1}% reduction)",
            bytes_saved,
            (bytes_saved as f64 / (total_individual_ids * 2) as f64) * 100.0
        );
        println!("\nðŸŽ¯ STRATEGY:");
        println!("  â€¢ Frequent patterns (â‰¥{} uses) â†’ Auto-grouped as MACROs", min_occurrences);
        println!("  â€¢ Rare patterns â†’ Kept ATOMIC for flexibility");
        println!("  â€¢ CSS file size: ~5 KB (gzipped)");
        println!("  â€¢ HTML payload: Smallest possible\n");
    }
}

impl Default for StyleAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_scan_html() {
        let html = r#"
            <div class="flex items-center p-4">Test</div>
            <div class="flex items-center p-4">Again</div>
            <span className="text-white bg-blue-500">Button</span>
        "#;

        let mut file = NamedTempFile::new().unwrap();
        file.write_all(html.as_bytes()).unwrap();
        file.flush().unwrap();

        let mut analyzer = StyleAnalyzer::new();
        analyzer.scan_file(file.path()).unwrap();

        let patterns = analyzer.get_top_patterns(10, 1);
        assert!(!patterns.is_empty());

        // "flex items-center p-4" should be detected twice
        let flex_pattern =
            patterns.iter().find(|p| p.classes == vec!["flex", "items-center", "p-4"]);

        assert!(flex_pattern.is_some());
        assert_eq!(flex_pattern.unwrap().count, 2);
    }

    #[test]
    fn test_pattern_detection() {
        let html = r#"
            <div class="a b c">1</div>
            <div class="a b c">2</div>
            <div class="a b c">3</div>
            <div class="x y z">4</div>
        "#;

        let mut file = NamedTempFile::new().unwrap();
        file.write_all(html.as_bytes()).unwrap();
        file.flush().unwrap();

        let mut analyzer = StyleAnalyzer::new();
        analyzer.scan_file(file.path()).unwrap();

        let patterns = analyzer.get_top_patterns(10, 2);

        // "a b c" should be top (3 occurrences) - but analyzer uses windows
        // so it detects 2-class and 3-class patterns separately
        assert!(!patterns.is_empty());
        // The top pattern should be "a b" or "b c" which appears 3 times (as a 2-class window)
        // or "a b c" which also appears 3 times (as a 3-class window)
        assert_eq!(patterns[0].count, 3);
    }

    #[test]
    fn test_generate_code() {
        let html = r#"
            <div class="flex items-center">1</div>
            <div class="flex items-center">2</div>
        "#;

        let mut file = NamedTempFile::new().unwrap();
        file.write_all(html.as_bytes()).unwrap();
        file.flush().unwrap();

        let mut analyzer = StyleAnalyzer::new();
        analyzer.scan_file(file.path()).unwrap();

        let code = analyzer.generate_combo_code(5, 1);

        // The generator creates AUTO_MACROS, not DETECTED_COMBOS
        assert!(code.contains("AUTO_MACROS"));
        assert!(code.contains("flex items-center"));
        assert!(code.contains("// Used 2 times"));
    }
}
