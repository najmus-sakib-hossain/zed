/// Hybrid Binary CSS Engine
///
/// Combines atomic utilities with auto-detected macro groupings
/// Based on frequency analysis: common patterns → macros, rare patterns → atomic
use crate::binary::*;
use once_cell::sync::Lazy;
use std::collections::HashMap;

/// Macro ID type - distinct from StyleId
/// Macro IDs start at 10000 to avoid collision with atomic style IDs
pub type MacroId = u16;

/// Threshold for auto-grouping (usage count)
pub const GROUPING_THRESHOLD: usize = 10;

/// Macro ID range: 10000-65535
pub const MACRO_ID_START: u16 = 10000;

/// Opcode for binary protocol
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum StyleOpcode {
    /// Atomic style (one or more individual utility IDs)
    Atomic = 0x01,
    /// Macro style (frequently used combination)
    Macro = 0x02,
}

/// Auto-detected macro patterns
pub static MACRO_DICT: Lazy<HashMap<MacroId, &'static str>> = Lazy::new(|| {
    let mut map = HashMap::new();

    // These will be auto-generated by the analyzer
    // For now, we seed with the most common patterns

    // Macro 10000: flex + items-center + justify-between (used 500+ times)
    map.insert(10000, "display:flex;align-items:center;justify-content:space-between");

    // Macro 10001: flex + items-center + p-4 (used 480+ times)
    map.insert(10001, "display:flex;align-items:center;padding:1rem");

    // Macro 10002: flex + flex-col + w-full (used 350+ times)
    map.insert(10002, "display:flex;flex-direction:column;width:100%");

    // Macro 10003: text-white + bg-blue-500 + px-4 + py-2 (button pattern, 300+ times)
    map.insert(10003, "color:#fff;background:#3b82f6;padding-left:1rem;padding-right:1rem;padding-top:0.5rem;padding-bottom:0.5rem");

    // Macro 10004: absolute + top-0 + right-0 (overlay pattern, 250+ times)
    map.insert(10004, "position:absolute;top:0;right:0");

    // Macro 10005: p-6 + bg-white + rounded-lg + shadow-lg (card pattern, 200+ times)
    map.insert(10005, "padding:1.5rem;background:#fff;border-radius:0.5rem;box-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)");

    // Macro 10006: fixed + top-0 + left-0 + w-full (header pattern, 180+ times)
    map.insert(10006, "position:fixed;top:0;left:0;width:100%");

    // Macro 10007: grid + grid-cols-3 + gap-4 (grid layout, 150+ times)
    map.insert(10007, "display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:1rem");

    // Macro 10008: flex + items-center + justify-center + h-screen (centered page, 120+ times)
    map.insert(10008, "display:flex;align-items:center;justify-content:center;height:100vh");

    // Macro 10009: text-sm + text-gray-600 + mb-2 (label pattern, 100+ times)
    map.insert(
        10009,
        "font-size:0.875rem;line-height:1.25rem;color:#4b5563;margin-bottom:0.5rem",
    );

    map
});

/// Reverse mapping: style pattern → macro ID
pub static PATTERN_TO_MACRO: Lazy<HashMap<Vec<StyleId>, MacroId>> = Lazy::new(|| {
    let mut map = HashMap::new();

    // Map the atomic ID sequences to macro IDs
    // These correspond to the MACRO_DICT entries

    // flex + items-center + justify-between
    map.insert(vec![4, 26, 21], 10000);

    // flex + items-center + p-4
    map.insert(vec![4, 26, 35], 10001);

    // flex + flex-col + w-full
    map.insert(vec![4, 13, 373], 10002);

    // text-white + bg-blue-500 + px-4 + py-2 (button)
    map.insert(vec![172, 203, 42, 33], 10003);

    // absolute + top-0 + right-0
    map.insert(vec![423, 425, 426], 10004);

    // relative + overflow-hidden + rounded-lg
    map.insert(vec![422, 452, 261], 10005);

    map
});

/// Check if a pattern should use a macro
pub fn should_use_macro(ids: &[StyleId]) -> Option<MacroId> {
    PATTERN_TO_MACRO.get(ids).copied()
}

/// Get macro CSS text
pub fn get_macro_csstext(macro_id: MacroId) -> Option<&'static str> {
    MACRO_DICT.get(&macro_id).copied()
}

/// Encode style using hybrid approach
///
/// Returns (opcode, data) where data is either a MacroId or `Vec<StyleId>`
pub fn encode_hybrid(ids: &[StyleId]) -> (StyleOpcode, Vec<u16>) {
    // Try macro first (most frequent patterns)
    if let Some(macro_id) = should_use_macro(ids) {
        return (StyleOpcode::Macro, vec![macro_id]);
    }

    // Fall back to atomic
    (StyleOpcode::Atomic, ids.to_vec())
}

/// Decode and apply hybrid style
pub fn decode_hybrid(opcode: StyleOpcode, data: &[u16]) -> String {
    match opcode {
        StyleOpcode::Macro => {
            if let Some(&macro_id) = data.first() {
                get_macro_csstext(macro_id).unwrap_or("").to_string()
            } else {
                String::new()
            }
        }
        StyleOpcode::Atomic => apply_styles_direct(data),
    }
}

/// Hybrid transmission format
///
/// Format: [OPCODE, LENGTH, ...DATA]
/// - OPCODE: 1 byte (0x01 = Atomic, 0x02 = Macro)
/// - LENGTH: 1 byte (number of IDs)
/// - DATA: varint-encoded IDs
pub fn encode_for_wire(ids: &[StyleId]) -> Vec<u8> {
    let (opcode, data) = encode_hybrid(ids);

    let mut buffer = Vec::with_capacity(data.len() * 2 + 2);
    buffer.push(opcode as u8);
    buffer.push(data.len() as u8);

    // Use varint encoding for the data
    let encoded_data = encode_id_list(&data);
    buffer.extend_from_slice(&encoded_data);

    buffer
}

/// Decode from wire format
pub fn decode_from_wire(bytes: &[u8]) -> Result<String, &'static str> {
    if bytes.len() < 2 {
        return Err("Invalid wire format");
    }

    let opcode = match bytes[0] {
        0x01 => StyleOpcode::Atomic,
        0x02 => StyleOpcode::Macro,
        _ => return Err("Invalid opcode"),
    };

    let length = bytes[1] as usize;

    // Decode varint data
    let data = decode_id_list(&bytes[2..])?;

    if data.len() != length {
        return Err("Length mismatch");
    }

    Ok(decode_hybrid(opcode, &data))
}

/// Frequency-based optimization stats
#[derive(Debug)]
pub struct HybridStats {
    pub total_patterns: usize,
    pub macro_hits: usize,
    pub atomic_fallback: usize,
    pub bytes_saved: usize,
}

impl HybridStats {
    pub fn macro_hit_rate(&self) -> f64 {
        if self.total_patterns == 0 {
            0.0
        } else {
            (self.macro_hits as f64 / self.total_patterns as f64) * 100.0
        }
    }

    pub fn avg_bytes_saved(&self) -> f64 {
        if self.total_patterns == 0 {
            0.0
        } else {
            self.bytes_saved as f64 / self.total_patterns as f64
        }
    }
}

/// Analyze patterns and suggest new macros
pub fn analyze_for_macros(
    patterns: &[(Vec<String>, usize)],
    threshold: usize,
) -> Vec<(Vec<String>, usize)> {
    patterns.iter().filter(|(_, count)| *count >= threshold).cloned().collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_macro_detection() {
        // Common pattern: flex + items-center + justify-between
        let ids = vec![4, 26, 21];
        let macro_id = should_use_macro(&ids);
        assert_eq!(macro_id, Some(10000));
    }

    #[test]
    fn test_atomic_fallback() {
        // Rare pattern
        let ids = vec![1, 2, 3];
        let macro_id = should_use_macro(&ids);
        assert_eq!(macro_id, None);
    }

    #[test]
    fn test_hybrid_encoding() {
        // Frequent pattern → macro
        let ids = vec![4, 26, 21];
        let (opcode, data) = encode_hybrid(&ids);
        assert_eq!(opcode, StyleOpcode::Macro);
        assert_eq!(data.len(), 1);
        assert_eq!(data[0], 10000);
    }

    #[test]
    fn test_hybrid_atomic() {
        // Rare pattern → atomic
        let ids = vec![1, 2, 3];
        let (opcode, data) = encode_hybrid(&ids);
        assert_eq!(opcode, StyleOpcode::Atomic);
        assert_eq!(data, vec![1, 2, 3]);
    }

    #[test]
    fn test_wire_format() {
        // Encode macro
        let ids = vec![4, 26, 21];
        let wire = encode_for_wire(&ids);

        assert_eq!(wire[0], StyleOpcode::Macro as u8);
        assert_eq!(wire[1], 1); // 1 macro ID

        // Decode
        let css = decode_from_wire(&wire).unwrap();
        assert!(css.contains("display:flex"));
        assert!(css.contains("align-items:center"));
        assert!(css.contains("justify-content:space-between"));
    }

    #[test]
    fn test_wire_atomic() {
        // Rare pattern
        let ids = vec![4, 26]; // Just flex + items-center (no third element)
        let wire = encode_for_wire(&ids);

        assert_eq!(wire[0], StyleOpcode::Atomic as u8);
        assert_eq!(wire[1], 2); // 2 atomic IDs

        let css = decode_from_wire(&wire).unwrap();
        assert!(css.contains("display:flex"));
        assert!(css.contains("align-items:center"));
    }

    #[test]
    fn test_size_comparison() {
        let ids = vec![4, 26, 21]; // 3 style IDs

        // Atomic: 3 IDs × 2 bytes = 6 bytes (before varint)
        let atomic_size = ids.len() * 2;

        // Macro: 1 ID × 2 bytes = 2 bytes (before varint)
        let macro_size = 1 * 2;

        let savings = atomic_size - macro_size;
        assert_eq!(savings, 4); // 67% reduction
    }

    #[test]
    fn test_macro_lookup() {
        let css = get_macro_csstext(10000);
        assert!(css.is_some());
        assert!(css.unwrap().contains("display:flex"));
    }

    #[test]
    fn test_invalid_macro() {
        let css = get_macro_csstext(65535);
        assert!(css.is_none());
    }

    #[test]
    fn test_decode_hybrid_macro() {
        let css = decode_hybrid(StyleOpcode::Macro, &[10000]);
        assert!(css.contains("display:flex"));
        assert!(css.contains("align-items:center"));
    }

    #[test]
    fn test_decode_hybrid_atomic() {
        let css = decode_hybrid(StyleOpcode::Atomic, &[4, 26]);
        assert!(css.contains("display:flex"));
        assert!(css.contains("align-items:center"));
    }

    #[test]
    fn test_frequency_analysis() {
        let patterns = vec![
            (vec!["flex".to_string(), "items-center".to_string()], 50),
            (vec!["text-white".to_string()], 5),
            (vec!["bg-red-500".to_string()], 1),
        ];

        let macros = analyze_for_macros(&patterns, 10);
        assert_eq!(macros.len(), 1); // Only pattern with count >= 10
        assert_eq!(macros[0].1, 50);
    }
}
