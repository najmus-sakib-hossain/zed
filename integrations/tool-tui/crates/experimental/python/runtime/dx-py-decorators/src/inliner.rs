//! Decorator inliner - transforms decorated functions at compile time

use crate::dataclass::DataclassInfo;
use crate::inlineable::FunctionFlags;
use crate::inlineable::InlineableDecorator;
use crate::lru_cache::InlineLruCache;
use std::collections::HashMap;

/// Result of inlining a decorator
#[derive(Debug)]
pub struct InlineResult {
    /// Modified bytecode (if any)
    pub bytecode: Option<Vec<u8>>,
    /// Function flags to set
    pub flags: FunctionFlags,
    /// Generated methods (for dataclass)
    pub generated_methods: Vec<GeneratedMethod>,
    /// Cache to attach (for lru_cache)
    pub cache: Option<InlineLruCache>,
}

/// A method generated by decorator inlining
#[derive(Debug)]
pub struct GeneratedMethod {
    /// Method name
    pub name: String,
    /// Method bytecode
    pub bytecode: Vec<u8>,
    /// Method flags
    pub flags: FunctionFlags,
}

/// Decorator inliner
pub struct DecoratorInliner {
    /// Registry of custom decorator handlers
    custom_decorators: HashMap<String, CustomDecoratorHandler>,
}

/// Type alias for custom decorator handler
type CustomDecoratorHandler = Box<dyn Fn(&[u8]) -> InlineResult + Send + Sync>;

impl DecoratorInliner {
    /// Create a new decorator inliner
    pub fn new() -> Self {
        Self {
            custom_decorators: HashMap::new(),
        }
    }

    /// Register a custom decorator handler
    pub fn register_custom<F>(&mut self, name: &str, handler: F)
    where
        F: Fn(&[u8]) -> InlineResult + Send + Sync + 'static,
    {
        self.custom_decorators.insert(name.to_string(), Box::new(handler));
    }

    /// Inline a decorator
    pub fn inline(
        &self,
        decorator: &InlineableDecorator,
        bytecode: &[u8],
        class_info: Option<&DataclassInfo>,
    ) -> InlineResult {
        match decorator {
            InlineableDecorator::StaticMethod => self.inline_staticmethod(bytecode),
            InlineableDecorator::ClassMethod => self.inline_classmethod(bytecode),
            InlineableDecorator::Property => self.inline_property(bytecode),
            InlineableDecorator::LruCache { maxsize } => self.inline_lru_cache(bytecode, *maxsize),
            InlineableDecorator::Dataclass {
                frozen,
                slots,
                eq,
                order,
                hash,
            } => self.inline_dataclass(class_info, *frozen, *slots, *eq, *order, *hash),
            InlineableDecorator::Jit => self.inline_jit(bytecode),
            InlineableDecorator::Parallel => self.inline_parallel(bytecode),
            InlineableDecorator::Custom(name) => {
                if let Some(handler) = self.custom_decorators.get(name) {
                    handler(bytecode)
                } else {
                    // No-op for unknown custom decorators
                    InlineResult {
                        bytecode: None,
                        flags: FunctionFlags::empty(),
                        generated_methods: Vec::new(),
                        cache: None,
                    }
                }
            }
        }
    }

    /// Inline @staticmethod - just set the flag
    fn inline_staticmethod(&self, _bytecode: &[u8]) -> InlineResult {
        InlineResult {
            bytecode: None, // No bytecode modification needed
            flags: FunctionFlags::STATIC_METHOD,
            generated_methods: Vec::new(),
            cache: None,
        }
    }

    /// Inline @classmethod - set flag, cls injection handled at call site
    fn inline_classmethod(&self, _bytecode: &[u8]) -> InlineResult {
        InlineResult {
            bytecode: None,
            flags: FunctionFlags::CLASS_METHOD,
            generated_methods: Vec::new(),
            cache: None,
        }
    }

    /// Inline @property - set flag, descriptor generated at class creation
    fn inline_property(&self, _bytecode: &[u8]) -> InlineResult {
        InlineResult {
            bytecode: None,
            flags: FunctionFlags::PROPERTY_GETTER,
            generated_methods: Vec::new(),
            cache: None,
        }
    }

    /// Inline @lru_cache - prepend cache lookup, append cache store
    fn inline_lru_cache(&self, bytecode: &[u8], maxsize: Option<usize>) -> InlineResult {
        // Create the cache
        let cache = InlineLruCache::new(maxsize.unwrap_or(128));

        // In a real implementation, we would modify the bytecode to:
        // 1. At function entry: check cache, return if hit
        // 2. Before each return: store result in cache

        // For now, we just attach the cache and set the flag
        // The interpreter/JIT will handle the cache logic

        InlineResult {
            bytecode: Some(bytecode.to_vec()), // Bytecode unchanged for now
            flags: FunctionFlags::HAS_CACHE,
            generated_methods: Vec::new(),
            cache: Some(cache),
        }
    }

    /// Inline @dataclass - generate __init__, __repr__, __eq__, etc.
    fn inline_dataclass(
        &self,
        class_info: Option<&DataclassInfo>,
        frozen: bool,
        _slots: bool,
        eq: bool,
        order: bool,
        hash: bool,
    ) -> InlineResult {
        let mut generated = Vec::new();

        if let Some(info) = class_info {
            // Generate __init__
            generated.push(GeneratedMethod {
                name: "__init__".to_string(),
                bytecode: info.generate_init(),
                flags: FunctionFlags::empty(),
            });

            // Generate __repr__
            generated.push(GeneratedMethod {
                name: "__repr__".to_string(),
                bytecode: info.generate_repr(),
                flags: FunctionFlags::empty(),
            });

            // Generate __eq__ if requested
            if eq {
                generated.push(GeneratedMethod {
                    name: "__eq__".to_string(),
                    bytecode: info.generate_eq(),
                    flags: FunctionFlags::empty(),
                });
            }

            // Generate __hash__ if frozen or explicitly requested
            if hash || frozen {
                generated.push(GeneratedMethod {
                    name: "__hash__".to_string(),
                    bytecode: info.generate_hash(),
                    flags: FunctionFlags::empty(),
                });
            }

            // Generate comparison methods if order requested
            if order {
                for method in ["__lt__", "__le__", "__gt__", "__ge__"] {
                    generated.push(GeneratedMethod {
                        name: method.to_string(),
                        bytecode: info.generate_comparison(method),
                        flags: FunctionFlags::empty(),
                    });
                }
            }
        }

        InlineResult {
            bytecode: None,
            flags: FunctionFlags::empty(),
            generated_methods: generated,
            cache: None,
        }
    }

    /// Inline @jit - mark for immediate JIT compilation
    fn inline_jit(&self, _bytecode: &[u8]) -> InlineResult {
        InlineResult {
            bytecode: None,
            flags: FunctionFlags::IMMEDIATE_JIT,
            generated_methods: Vec::new(),
            cache: None,
        }
    }

    /// Inline @parallel - mark for auto-parallelization
    fn inline_parallel(&self, _bytecode: &[u8]) -> InlineResult {
        InlineResult {
            bytecode: None,
            flags: FunctionFlags::AUTO_PARALLEL,
            generated_methods: Vec::new(),
            cache: None,
        }
    }
}

impl Default for DecoratorInliner {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_inline_staticmethod() {
        let inliner = DecoratorInliner::new();
        let result = inliner.inline(&InlineableDecorator::StaticMethod, &[], None);

        assert!(result.flags.contains(FunctionFlags::STATIC_METHOD));
        assert!(result.bytecode.is_none());
    }

    #[test]
    fn test_inline_lru_cache() {
        let inliner = DecoratorInliner::new();
        let result = inliner.inline(
            &InlineableDecorator::LruCache { maxsize: Some(64) },
            &[0xF0], // NOP
            None,
        );

        assert!(result.flags.contains(FunctionFlags::HAS_CACHE));
        assert!(result.cache.is_some());
    }

    #[test]
    fn test_inline_jit() {
        let inliner = DecoratorInliner::new();
        let result = inliner.inline(&InlineableDecorator::Jit, &[], None);

        assert!(result.flags.contains(FunctionFlags::IMMEDIATE_JIT));
    }

    #[test]
    fn test_custom_decorator() {
        let mut inliner = DecoratorInliner::new();

        inliner.register_custom("my_decorator", |_| InlineResult {
            bytecode: Some(vec![0x01, 0x02]),
            flags: FunctionFlags::HAS_TYPES,
            generated_methods: Vec::new(),
            cache: None,
        });

        let result =
            inliner.inline(&InlineableDecorator::Custom("my_decorator".to_string()), &[], None);

        assert!(result.flags.contains(FunctionFlags::HAS_TYPES));
        assert_eq!(result.bytecode, Some(vec![0x01, 0x02]));
    }
}
