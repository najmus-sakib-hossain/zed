
# dx-generator: Binary Dawn Edition

The world's fastest, most efficient code generatorâ€”built on Dx principles. "Generate Binary. Cache Binary. Diff Binary. Zero Parse."

## Performance Targets

+-----------+-------------+--------------+-------------+
| Operation | Traditional | dx-generator | Improvement |
+===========+=============+==============+=============+
| Template  | Load        | ~5ms         | (parse      |
+-----------+-------------+--------------+-------------+



## Key Features

- Binary Template Format (.dxt)
- Pre-compiled templates with zero runtime parsing
- Smart Placeholders
- Type-aware placeholders with transforms (PascalCase, snake_case, etc.)
- XOR Differential Regeneration
- 95% reduction in disk writes through binary diff patching
- Protected Regions
- Preserve manual edits with `// @dx:preserve` markers
- Template Registry
- Discover, install, and publish templates
- Fusion Mode
- Multi-file scaffold bundles for instant project generation
- AI Agent Protocol
- JSON-RPC interface for AI-assisted code generation
- Capability-Based Security
- Ed25519 signed templates with permission manifests

## CLI Usage

### Generate from Template

```bash


# Generate a component


dx gen run component --param name=Counter --param with_state=true


# Preview without writing (dry run)


dx gen run component --param name=Counter --dry-run


# Force overwrite existing files


dx gen run component --param name=Counter --force ```


### List Available Templates


```bash

# List all templates

dx gen list

# Filter by category

dx gen list --category rust

# Output as JSON

dx gen list --format json ```

### Initialize Template Directory

```bash


# Create .dx/templates/ with example templates


dx gen init --examples ```


### Compile Templates


```bash

# Compile a template to binary format

dx gen compile component.dxt.hbs -o component.dxt

# Validate only (no output)

dx gen compile component.dxt.hbs --check ```

### Scaffold Multi-File Projects

```bash


# Scaffold a Rust crate


dx gen scaffold rust-crate --param name=my_lib --param description="My library"


# Scaffold a React component with tests


dx gen scaffold react-component --param name=Button --param withStory=true ```


### Watch Mode


```bash

# Watch for file changes and regenerate

dx gen watch

# Use custom config

dx gen watch --config my-dx.toml ```

### View Statistics

```bash


# Show generation metrics


dx gen stats


# Reset statistics


dx gen stats --reset ```


### Registry Operations


```bash

# Search for templates

dx gen registry search component

# Install a template

dx gen registry install @dx/react-component

# Publish a template

dx gen registry publish ```

## Template Authoring Guide

### Basic Template Syntax

Templates use Handlebars-like syntax:
```handlebars
{{! component.dxt.hbs }}
//! {{ name }} Component //! Generated by dx-generator pub struct {{ name }} { value: i32, }
impl {{ name }} { pub fn new() -> Self { Self { value: 0 }
}
}
```

### Smart Placeholders with Types

Specify types for automatic validation and transformation:
```handlebars
{{! Use PascalCase for struct names }}
pub struct {{ name: PascalCase }} { {{! Use snake_case for field names }}
{{ field_name: snake_case }}: {{ field_type }}, }
```

### Transform Pipeline

Apply transforms to placeholder values:
```handlebars
{{! Original: "user_profile" }}
{{ name | pascal_case }} {{! Output: "UserProfile" }}
{{ name | kebab_case }} {{! Output: "user-profile" }}
{{ name | uppercase }} {{! Output: "USER_PROFILE" }}
{{ name | pluralize }} {{! Output: "user_profiles" }}
```

### Conditionals

```handlebars
{% if with_state %}
use dx_state::State;
{% endif %}
{% if feature == "async" %}
async fn process() { }
{% else %}
fn process() { }
{% endif %}
```

### Loops

```handlebars
pub struct {{ name }} { {% for field in fields %}
{{ field.name }}: {{ field.type }}, {% endfor %}
}
```

### Protected Regions

Mark regions that should be preserved during regeneration:
```rust
impl MyComponent { // @dx:preserve start // Custom implementation - won't be overwritten fn custom_logic(&self) { // Your code here }
// @dx:preserve end }
```

### Default Values

```handlebars
{{! Use default if not provided }}
{{ description | default: "A generated component" }}
```

## AI Agent Integration Guide

### JSON-RPC Protocol

AI agents can invoke generation via JSON-RPC:
```json
{ "jsonrpc": "2.0", "id": 1, "method": "generate", "params": { "template": "component", "parameters": { "name": "Counter", "with_state": true }, "output": "src/components/counter.rs", "dry_run": false }
}
```

### Response Format

```json
{ "jsonrpc": "2.0", "id": 1, "result": { "content": "// Generated component code...", "output_path": "src/components/counter.rs", "bytes": 1234, "time_us": 150, "tokens_saved": 308 }
}
```

### Available Methods

+------------+-------------+
| Method     | Description |
+============+=============+
| `generate` | Generate    |
+------------+-------------+



### Intelligent Defaults

The generator infers defaults from context: -`name` - Inferred from current directory name -`author` - Inferred from git config -`date` - Current date in ISO format

## Programmatic Usage

```rust
use dx_generator::{Generator, Template, Parameters};
// Load pre-compiled binary template let template = Template::load("component.dxt")?;
// Create parameters let params = Parameters::new()
.set("name", "Counter")
.set("with_state", true)
.set("state_vars", vec!["count", "loading"]);
// Generate let output = Generator::new()
.with_template(template)
.with_params(params)
.generate()?;
// Write to file (applies XOR patch if file exists)
output.write_to("src/components/counter.rs")?;
```

### Using the Registry

```rust
use dx_generator::registry::TemplateRegistry;
let registry = TemplateRegistry::new(".dx/templates")?;
// Search for templates let results = registry.search("component");
// Get template metadata if let Some(meta) = registry.get("component") { println!("Template: {}", meta.name);
println!("Parameters: {:?}", meta.parameters);
}
```

### Metrics Tracking

```rust
use dx_generator::metrics::MetricsTracker;
let mut tracker = MetricsTracker::new(".dx/stats.json")?;
// Record a generation tracker.record_generation("component", 1234, 150);
// Get statistics let stats = tracker.stats();
println!("Total generations: {}", stats.total_generations);
println!("Tokens saved: {}", stats.estimated_tokens_saved);
```

## Configuration

Configure dx-generator in `dx.toml`:
```toml
[generator]


# Template search paths


template_paths = [".dx/templates", "~/.dx/templates"]


# Default output directory


output_dir = "src/generated"


# Enable XOR patching


enable_patching = true


# Watch mode configuration


[generator.watch]
enabled = false debounce_ms = 500 patterns = ["src/**/*.schema.json"]


# Hook definitions


[[generator.hooks]]
trigger = "src/schemas/*.json"
template = "model"
output = "src/models/{{ name | pascal_case }}.rs"
```

## Architecture

@tree[]

## Binary Template Format (.dxt)

@tree[]

## License

MIT OR Apache-2.0 Binary Dawn Code Generation - Generate Binary. Cache Binary. Diff Binary. Zero Parse.
