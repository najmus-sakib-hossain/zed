//! # Schema-Driven Admin Panel Generation
//!
//! Auto-generate admin panels from database schema as binary templates.
//! Target: ~50KB bundle (10x smaller than Django's ~500KB).
//!
//! **Validates: Requirements 21.1, 21.2, 21.3, 21.4**

/// Admin configuration containing all model definitions
#[derive(Debug, Clone, Default)]
pub struct AdminConfig {
    /// Model admin definitions
    pub models: Vec<ModelAdmin>,
    /// Site title
    pub site_title: String,
    /// Base URL path for admin
    pub base_path: String,
}

impl AdminConfig {
    /// Create a new admin config
    pub fn new() -> Self {
        Self {
            models: Vec::new(),
            site_title: "Admin".to_string(),
            base_path: "/admin".to_string(),
        }
    }

    /// Set the site title
    pub fn with_title(mut self, title: impl Into<String>) -> Self {
        self.site_title = title.into();
        self
    }

    /// Set the base path
    pub fn with_base_path(mut self, path: impl Into<String>) -> Self {
        self.base_path = path.into();
        self
    }

    /// Add a model admin
    pub fn add_model(mut self, model: ModelAdmin) -> Self {
        self.models.push(model);
        self
    }

    /// Get a model by table name
    pub fn get_model(&self, table_name: &str) -> Option<&ModelAdmin> {
        self.models.iter().find(|m| m.table_name == table_name)
    }

    /// Generate routes for all models
    pub fn generate_routes(&self) -> Vec<AdminRoute> {
        let mut routes = Vec::new();

        // Index route
        routes.push(AdminRoute {
            path: self.base_path.clone(),
            route_type: AdminRouteType::Index,
            model_name: None,
        });

        // Model routes
        for model in &self.models {
            let model_path = format!("{}/{}", self.base_path, model.table_name);

            // List route
            routes.push(AdminRoute {
                path: model_path.clone(),
                route_type: AdminRouteType::List,
                model_name: Some(model.table_name.to_string()),
            });

            // Create route
            routes.push(AdminRoute {
                path: format!("{}/new", model_path),
                route_type: AdminRouteType::Create,
                model_name: Some(model.table_name.to_string()),
            });

            // Edit route
            routes.push(AdminRoute {
                path: format!("{}/:id", model_path),
                route_type: AdminRouteType::Edit,
                model_name: Some(model.table_name.to_string()),
            });

            // Delete route
            routes.push(AdminRoute {
                path: format!("{}/:id/delete", model_path),
                route_type: AdminRouteType::Delete,
                model_name: Some(model.table_name.to_string()),
            });
        }

        routes
    }
}

/// Model admin definition
///
/// Generated by `#[derive(Admin)]` macro from struct definition.
#[derive(Debug, Clone)]
pub struct ModelAdmin {
    /// Database table name
    pub table_name: &'static str,
    /// Template ID for list view
    pub list_template: u16,
    /// Template ID for edit view
    pub edit_template: u16,
    /// Columns to display in list view
    pub list_columns: Vec<Column>,
    /// Available filters
    pub filters: Vec<Filter>,
    /// Fields to search
    pub search_fields: Vec<u8>,
    /// Display name for the model
    pub display_name: String,
    /// Icon for the model (optional)
    pub icon: Option<String>,
}

impl ModelAdmin {
    /// Create a new model admin
    pub fn new(table_name: &'static str) -> Self {
        Self {
            table_name,
            list_template: 0,
            edit_template: 0,
            list_columns: Vec::new(),
            filters: Vec::new(),
            search_fields: Vec::new(),
            display_name: table_name.to_string(),
            icon: None,
        }
    }

    /// Set the list template ID
    pub fn with_list_template(mut self, template_id: u16) -> Self {
        self.list_template = template_id;
        self
    }

    /// Set the edit template ID
    pub fn with_edit_template(mut self, template_id: u16) -> Self {
        self.edit_template = template_id;
        self
    }

    /// Add a column
    pub fn add_column(mut self, column: Column) -> Self {
        self.list_columns.push(column);
        self
    }

    /// Add a filter
    pub fn add_filter(mut self, filter: Filter) -> Self {
        self.filters.push(filter);
        self
    }

    /// Add a search field
    pub fn add_search_field(mut self, field_id: u8) -> Self {
        self.search_fields.push(field_id);
        self
    }

    /// Set the display name
    pub fn with_display_name(mut self, name: impl Into<String>) -> Self {
        self.display_name = name.into();
        self
    }

    /// Set the icon
    pub fn with_icon(mut self, icon: impl Into<String>) -> Self {
        self.icon = Some(icon.into());
        self
    }
}

/// Column definition for list view
#[derive(Debug, Clone)]
pub struct Column {
    /// Field ID in the schema
    pub field_id: u8,
    /// Display name for the column
    pub display_name: &'static str,
    /// Whether the column is sortable
    pub sortable: bool,
    /// Whether the column is filterable
    pub filterable: bool,
    /// Column width (optional)
    pub width: Option<u16>,
    /// Column type for rendering
    pub column_type: ColumnType,
}

impl Column {
    /// Create a new column
    pub fn new(field_id: u8, display_name: &'static str) -> Self {
        Self {
            field_id,
            display_name,
            sortable: false,
            filterable: false,
            width: None,
            column_type: ColumnType::Text,
        }
    }

    /// Make the column sortable
    pub fn sortable(mut self) -> Self {
        self.sortable = true;
        self
    }

    /// Make the column filterable
    pub fn filterable(mut self) -> Self {
        self.filterable = true;
        self
    }

    /// Set the column width
    pub fn with_width(mut self, width: u16) -> Self {
        self.width = Some(width);
        self
    }

    /// Set the column type
    pub fn with_type(mut self, column_type: ColumnType) -> Self {
        self.column_type = column_type;
        self
    }
}

/// Column type for rendering
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ColumnType {
    /// Plain text
    Text,
    /// Numeric value
    Number,
    /// Boolean (checkbox)
    Boolean,
    /// Date/time
    DateTime,
    /// Email address
    Email,
    /// URL link
    Url,
    /// Image thumbnail
    Image,
    /// Foreign key reference
    ForeignKey,
    /// JSON data
    Json,
}

/// Filter definition
#[derive(Debug, Clone)]
pub struct Filter {
    /// Field ID to filter on
    pub field_id: u8,
    /// Display name for the filter
    pub display_name: &'static str,
    /// Filter type
    pub filter_type: FilterType,
    /// Available options (for select filters)
    pub options: Vec<FilterOption>,
}

impl Filter {
    /// Create a new filter
    pub fn new(field_id: u8, display_name: &'static str, filter_type: FilterType) -> Self {
        Self {
            field_id,
            display_name,
            filter_type,
            options: Vec::new(),
        }
    }

    /// Add an option
    pub fn add_option(mut self, option: FilterOption) -> Self {
        self.options.push(option);
        self
    }
}

/// Filter type
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FilterType {
    /// Exact match
    Exact,
    /// Contains (for text)
    Contains,
    /// Range (for numbers/dates)
    Range,
    /// Select from options
    Select,
    /// Boolean toggle
    Boolean,
    /// Date range
    DateRange,
}

/// Filter option for select filters
#[derive(Debug, Clone)]
pub struct FilterOption {
    /// Option value
    pub value: String,
    /// Display label
    pub label: String,
}

impl FilterOption {
    /// Create a new filter option
    pub fn new(value: impl Into<String>, label: impl Into<String>) -> Self {
        Self {
            value: value.into(),
            label: label.into(),
        }
    }
}

/// Admin route definition
#[derive(Debug, Clone)]
pub struct AdminRoute {
    /// Route path
    pub path: String,
    /// Route type
    pub route_type: AdminRouteType,
    /// Model name (if applicable)
    pub model_name: Option<String>,
}

/// Admin route type
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AdminRouteType {
    /// Admin index page
    Index,
    /// Model list view
    List,
    /// Create new record
    Create,
    /// Edit existing record
    Edit,
    /// Delete record
    Delete,
}

/// Builder for creating admin panels
pub struct AdminBuilder {
    config: AdminConfig,
}

impl AdminBuilder {
    /// Create a new admin builder
    pub fn new() -> Self {
        Self {
            config: AdminConfig::new(),
        }
    }

    /// Set the site title
    pub fn title(mut self, title: impl Into<String>) -> Self {
        self.config.site_title = title.into();
        self
    }

    /// Set the base path
    pub fn base_path(mut self, path: impl Into<String>) -> Self {
        self.config.base_path = path.into();
        self
    }

    /// Register a model
    pub fn register(mut self, model: ModelAdmin) -> Self {
        self.config.models.push(model);
        self
    }

    /// Build the admin config
    pub fn build(self) -> AdminConfig {
        self.config
    }
}

impl Default for AdminBuilder {
    fn default() -> Self {
        Self::new()
    }
}

/// Estimate the bundle size for an admin config
///
/// Target: ~50KB (10x smaller than Django's ~500KB)
pub fn estimate_bundle_size(config: &AdminConfig) -> usize {
    let mut size = 0usize;

    // Base admin shell: ~5KB
    size += 5000;

    // Per-model overhead: ~2KB each
    size += config.models.len() * 2000;

    // Per-column overhead: ~100 bytes each
    for model in &config.models {
        size += model.list_columns.len() * 100;
        size += model.filters.len() * 150;
    }

    size
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_admin_config_creation() {
        let config = AdminConfig::new().with_title("My Admin").with_base_path("/dashboard");

        assert_eq!(config.site_title, "My Admin");
        assert_eq!(config.base_path, "/dashboard");
        assert!(config.models.is_empty());
    }

    #[test]
    fn test_model_admin_creation() {
        let model = ModelAdmin::new("users")
            .with_display_name("Users")
            .with_list_template(1)
            .with_edit_template(2)
            .add_column(Column::new(0, "ID").sortable())
            .add_column(Column::new(1, "Name").sortable().filterable())
            .add_search_field(1);

        assert_eq!(model.table_name, "users");
        assert_eq!(model.display_name, "Users");
        assert_eq!(model.list_template, 1);
        assert_eq!(model.edit_template, 2);
        assert_eq!(model.list_columns.len(), 2);
        assert_eq!(model.search_fields, vec![1]);
    }

    #[test]
    fn test_column_creation() {
        let column = Column::new(0, "Email")
            .sortable()
            .filterable()
            .with_width(200)
            .with_type(ColumnType::Email);

        assert_eq!(column.field_id, 0);
        assert_eq!(column.display_name, "Email");
        assert!(column.sortable);
        assert!(column.filterable);
        assert_eq!(column.width, Some(200));
        assert_eq!(column.column_type, ColumnType::Email);
    }

    #[test]
    fn test_filter_creation() {
        let filter = Filter::new(0, "Status", FilterType::Select)
            .add_option(FilterOption::new("active", "Active"))
            .add_option(FilterOption::new("inactive", "Inactive"));

        assert_eq!(filter.field_id, 0);
        assert_eq!(filter.display_name, "Status");
        assert_eq!(filter.filter_type, FilterType::Select);
        assert_eq!(filter.options.len(), 2);
    }

    #[test]
    fn test_route_generation() {
        let config = AdminConfig::new()
            .with_base_path("/admin")
            .add_model(ModelAdmin::new("users"))
            .add_model(ModelAdmin::new("posts"));

        let routes = config.generate_routes();

        // Should have: index + (list, create, edit, delete) * 2 models = 9 routes
        assert_eq!(routes.len(), 9);

        // Check index route
        assert!(
            routes
                .iter()
                .any(|r| r.path == "/admin" && r.route_type == AdminRouteType::Index)
        );

        // Check user routes
        assert!(
            routes
                .iter()
                .any(|r| r.path == "/admin/users" && r.route_type == AdminRouteType::List)
        );
        assert!(
            routes
                .iter()
                .any(|r| r.path == "/admin/users/new" && r.route_type == AdminRouteType::Create)
        );
        assert!(
            routes
                .iter()
                .any(|r| r.path == "/admin/users/:id" && r.route_type == AdminRouteType::Edit)
        );
    }

    #[test]
    fn test_get_model() {
        let config = AdminConfig::new()
            .add_model(ModelAdmin::new("users"))
            .add_model(ModelAdmin::new("posts"));

        assert!(config.get_model("users").is_some());
        assert!(config.get_model("posts").is_some());
        assert!(config.get_model("comments").is_none());
    }

    #[test]
    fn test_admin_builder() {
        let config = AdminBuilder::new()
            .title("Dashboard")
            .base_path("/dashboard")
            .register(ModelAdmin::new("users"))
            .build();

        assert_eq!(config.site_title, "Dashboard");
        assert_eq!(config.base_path, "/dashboard");
        assert_eq!(config.models.len(), 1);
    }

    #[test]
    fn test_bundle_size_estimation() {
        // Empty config
        let empty_config = AdminConfig::new();
        let empty_size = estimate_bundle_size(&empty_config);
        assert_eq!(empty_size, 5000); // Base shell only

        // Config with models
        let config = AdminConfig::new()
            .add_model(
                ModelAdmin::new("users")
                    .add_column(Column::new(0, "ID"))
                    .add_column(Column::new(1, "Name"))
                    .add_filter(Filter::new(0, "Status", FilterType::Select)),
            )
            .add_model(ModelAdmin::new("posts"));

        let size = estimate_bundle_size(&config);

        // Base (5000) + 2 models (4000) + 2 columns (200) + 1 filter (150) = 9350
        assert_eq!(size, 9350);

        // Should be well under 50KB target
        assert!(size < 50000);
    }

    #[test]
    fn test_column_types() {
        let types = [
            ColumnType::Text,
            ColumnType::Number,
            ColumnType::Boolean,
            ColumnType::DateTime,
            ColumnType::Email,
            ColumnType::Url,
            ColumnType::Image,
            ColumnType::ForeignKey,
            ColumnType::Json,
        ];

        // All types should be distinct
        for (i, t1) in types.iter().enumerate() {
            for (j, t2) in types.iter().enumerate() {
                if i != j {
                    assert_ne!(t1, t2);
                }
            }
        }
    }

    #[test]
    fn test_filter_types() {
        let types = [
            FilterType::Exact,
            FilterType::Contains,
            FilterType::Range,
            FilterType::Select,
            FilterType::Boolean,
            FilterType::DateRange,
        ];

        // All types should be distinct
        for (i, t1) in types.iter().enumerate() {
            for (j, t2) in types.iter().enumerate() {
                if i != j {
                    assert_ne!(t1, t2);
                }
            }
        }
    }
}
