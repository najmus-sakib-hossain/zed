//! # Macro Codegen - The 7.5KB Generator
//!
//! Generates Rust code for the full-featured Macro runtime.
//! Uses Binary Templates + SharedArrayBuffer for optimal performance.
//!
//! ## Architecture
//! ```text
//! TSX: <div class="box">{count}</div>
//!       ↓
//! 1. layout.bin: Static HTML with <!--SLOT_N--> placeholders
//! 2. generated.rs: AppState struct + Component trait implementation
//! ```
//!
//! ## Strategy
//! - Extract static structure → Binary template
//! - Dynamic parts → Slot placeholders
//! - State → SharedArrayBuffer-backed struct
//! - Updates → HTIP batch operations

use anyhow::Result;
use std::path::Path;

use crate::splitter::{Binding, StateSchema, Template};

// ============================================================================
// Layout Binary Format
// ============================================================================

/// Binary layout header
const LAYOUT_MAGIC: u32 = 0x4C415944; // "LAYD"
const LAYOUT_VERSION: u8 = 1;

/// Serialize templates to layout.bin
pub fn serialize_layout(templates: &[Template], output_dir: &Path) -> Result<()> {
    let layout_path = output_dir.join("layout.bin");

    let mut data = Vec::new();

    // Header
    data.extend(&LAYOUT_MAGIC.to_le_bytes());
    data.push(LAYOUT_VERSION);
    data.push(0); // reserved
    data.extend(&(templates.len() as u16).to_le_bytes());

    // Template entries: [id: u16, html_offset: u32, html_len: u16, slot_count: u8, reserved: u8]
    let mut html_data: Vec<u8> = Vec::new();
    let mut entries: Vec<u8> = Vec::new();

    for template in templates {
        let offset = html_data.len() as u32;
        let html_bytes = template.html.as_bytes();
        let len = html_bytes.len() as u16;

        entries.extend(&(template.id as u16).to_le_bytes());
        entries.extend(&offset.to_le_bytes());
        entries.extend(&len.to_le_bytes());
        entries.push(template.slots.len() as u8);
        entries.push(0); // reserved

        html_data.extend(html_bytes);
    }

    // Write entries then data
    data.extend(&entries);
    data.extend(&html_data);

    std::fs::write(&layout_path, &data)?;

    Ok(())
}

// ============================================================================
// Rust Glue Code Generator
// ============================================================================

/// Generate Macro-mode Rust code from templates and bindings
///
/// This generates:
/// 1. AppState struct backed by SharedArrayBuffer
/// 2. Component trait implementation
/// 3. update() method that writes to shared memory
pub fn generate_macro(
    templates: &[Template],
    bindings: &[Binding],
    schemas: &[StateSchema],
    verbose: bool,
) -> Result<String> {
    if verbose {
        println!("  [Macro] Generating Rust glue code...");
    }

    let mut output = vec![
        "//! Generated by dx-compiler (Macro Mode)".to_string(),
        "//! DO NOT EDIT - This file is automatically generated".to_string(),
        "".to_string(),
        "#![no_std]".to_string(),
        "#![no_main]".to_string(),
        "".to_string(),
    ];

    // Panic handler
    output.push("#[panic_handler]".to_string());
    output.push("fn panic(_: &core::panic::PanicInfo) -> ! {".to_string());
    output.push("    unsafe { core::arch::wasm32::unreachable() }".to_string());
    output.push("}".to_string());
    output.push("".to_string());

    // FFI imports for Macro mode (HTIP-based)
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("// FFI: JavaScript Host Functions (HTIP Protocol)".to_string());
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("".to_string());
    output.push("extern \"C\" {".to_string());
    output.push("    /// Clone template by ID, returns node handle".to_string());
    output.push("    fn host_clone_template(template_id: u32) -> u32;".to_string());
    output.push("    /// Append child to parent".to_string());
    output.push("    fn host_append(parent_id: u32, child_id: u32);".to_string());
    output.push("    /// Set text by slot ID".to_string());
    output.push(
        "    fn host_patch_slot(node_id: u32, slot_id: u32, ptr: *const u8, len: u32);".to_string(),
    );
    output.push("    /// Queue render batch".to_string());
    output.push("    fn host_flush_render();".to_string());
    output.push("    /// Get shared memory pointer".to_string());
    output.push("    fn host_get_shared_buffer() -> *mut u8;".to_string());
    output.push("}".to_string());
    output.push("".to_string());

    // Template ID constants
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("// Template IDs".to_string());
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("".to_string());
    for template in templates {
        let name = format!("TEMPLATE_{}", template.id);
        output.push(format!("const {}: u32 = {};", name, template.id));
    }
    output.push("".to_string());

    // Generate AppState struct for each component
    for schema in schemas {
        output.push(generate_state_struct(schema)?);
        output.push("".to_string());
    }

    // Generate slot binding constants
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("// Slot Bindings".to_string());
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("".to_string());
    for binding in bindings {
        let sanitized_expr: String = binding
            .expression
            .chars()
            .take(50)
            .map(|c| match c {
                '\n' | '\r' => ' ',
                _ => c,
            })
            .collect();
        output.push(format!(
            "const SLOT_{}: u32 = {}; // <- {}",
            binding.slot_id, binding.slot_id, sanitized_expr
        ));
    }
    output.push("".to_string());

    // Init function
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("// WASM Exports".to_string());
    output.push(
        "// ============================================================================"
            .to_string(),
    );
    output.push("".to_string());
    output.push("#[no_mangle]".to_string());
    output.push("pub extern \"C\" fn init() -> u32 {".to_string());
    output.push("    // Initialize shared buffer".to_string());
    output.push("    unsafe {".to_string());
    output.push("        let _shared = host_get_shared_buffer();".to_string());
    output.push("    }".to_string());
    output.push("    0 // Success".to_string());
    output.push("}".to_string());
    output.push("".to_string());

    // Render function
    output.push("/// Initial render - clone templates and set up DOM".to_string());
    output.push("#[no_mangle]".to_string());
    output.push("pub extern \"C\" fn render() {".to_string());
    output.push("    unsafe {".to_string());

    for template in templates {
        output.push(format!(
            "        let node_{} = host_clone_template(TEMPLATE_{});",
            template.id, template.id
        ));
        output.push(format!("        host_append(0, node_{});", template.id));
    }

    output.push("        host_flush_render();".to_string());
    output.push("    }".to_string());
    output.push("}".to_string());
    output.push("".to_string());

    // Update function - patches slots with new values
    output.push("/// Update DOM with current state values".to_string());
    output.push("#[no_mangle]".to_string());
    output.push("pub extern \"C\" fn update() {".to_string());
    output.push("    unsafe {".to_string());
    output.push("        // Read from shared buffer and patch slots".to_string());

    for binding in bindings {
        let var_name = binding
            .expression
            .replace("self.", "")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '_')
            .collect::<String>()
            .to_uppercase();
        let sanitized_expr: String = binding
            .expression
            .chars()
            .take(50)
            .map(|c| match c {
                '\n' | '\r' => ' ',
                _ => c,
            })
            .collect();

        output.push(format!("        // Patch slot {} with {}", binding.slot_id, sanitized_expr));
        output.push(format!(
            "        // host_patch_slot(node_id, SLOT_{}, {}_PTR, {}_LEN);",
            binding.slot_id, var_name, var_name
        ));
    }

    output.push("        host_flush_render();".to_string());
    output.push("    }".to_string());
    output.push("}".to_string());
    output.push("".to_string());

    // Event dispatcher
    output.push("/// Event dispatcher - called by JS with event ID".to_string());
    output.push("#[no_mangle]".to_string());
    output.push("pub extern \"C\" fn on_event(id: u32) {".to_string());
    output.push("    match id {".to_string());
    output.push("        _ => {}".to_string());
    output.push("    }".to_string());
    output.push("}".to_string());

    if verbose {
        println!("    Generated {} lines of Macro Rust code", output.len());
        println!("    Templates: {}", templates.len());
        println!("    Bindings: {}", bindings.len());
        println!("    State schemas: {}", schemas.len());
    }

    Ok(output.join("\n"))
}

/// Generate a state struct for a component
fn generate_state_struct(schema: &StateSchema) -> Result<String> {
    let mut lines = Vec::new();

    let struct_name = format!("{}State", schema.component);

    lines.push(format!("/// State for {} component", schema.component));
    lines.push("#[repr(C)]".to_string());
    lines.push(format!("pub struct {} {{", struct_name));

    for field in &schema.fields {
        let rust_type = type_to_rust(&field.type_name);
        lines.push(format!("    pub {}: {},", field.name, rust_type));
    }

    lines.push("}".to_string());
    lines.push("".to_string());

    // Default impl
    lines.push(format!("impl Default for {} {{", struct_name));
    lines.push("    fn default() -> Self {".to_string());
    lines.push("        Self {".to_string());

    for field in &schema.fields {
        let default_val = default_value(&field.type_name, &field.initial_value);
        lines.push(format!("            {}: {},", field.name, default_val));
    }

    lines.push("        }".to_string());
    lines.push("    }".to_string());
    lines.push("}".to_string());

    Ok(lines.join("\n"))
}

/// Convert TypeScript type to Rust type
fn type_to_rust(ts_type: &str) -> &'static str {
    match ts_type {
        "number" => "i32",
        "boolean" => "bool",
        "string" => "&'static str",
        _ => "i32",
    }
}

/// Generate default value for a field
fn default_value(ts_type: &str, initial: &str) -> String {
    if initial == "null" || initial == "undefined" {
        return match ts_type {
            "boolean" => "false".to_string(),
            "string" => "\"\"".to_string(),
            _ => "0".to_string(),
        };
    }

    if initial == "[]" {
        return "0".to_string(); // Pointers/handles use 0 as null
    }

    match ts_type {
        "number" => initial.to_string(),
        "boolean" => initial.to_string(),
        "string" => format!("\"{}\"", initial.trim_matches('"')),
        _ => initial.to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::splitter::StateField;

    #[test]
    fn test_generate_macro_empty() {
        let result = generate_macro(&[], &[], &[], false);
        assert!(result.is_ok());

        let code = result.unwrap();
        assert!(code.contains("#![no_std]"));
        assert!(code.contains("host_clone_template"));
        assert!(code.contains("pub extern \"C\" fn render()"));
        assert!(code.contains("pub extern \"C\" fn update()"));
    }

    #[test]
    fn test_generate_state_struct() {
        let schema = StateSchema {
            component: "Counter".to_string(),
            fields: vec![StateField {
                name: "count".to_string(),
                type_name: "number".to_string(),
                initial_value: "0".to_string(),
                dirty_bit: 0,
            }],
        };

        let result = generate_state_struct(&schema);
        assert!(result.is_ok());

        let code = result.unwrap();
        assert!(code.contains("pub struct CounterState"));
        assert!(code.contains("pub count: i32"));
        assert!(code.contains("impl Default"));
    }

    #[test]
    fn test_serialize_layout() {
        let templates = vec![Template {
            id: 0,
            html: "<div>Hello</div>".to_string(),
            slots: vec![],
            hash: "test".to_string(),
        }];

        let temp_dir = std::env::temp_dir();
        let result = serialize_layout(&templates, &temp_dir);
        assert!(result.is_ok());

        let layout_path = temp_dir.join("layout.bin");
        assert!(layout_path.exists());

        let data = std::fs::read(&layout_path).unwrap();
        assert_eq!(&data[0..4], &LAYOUT_MAGIC.to_le_bytes());
    }
}
