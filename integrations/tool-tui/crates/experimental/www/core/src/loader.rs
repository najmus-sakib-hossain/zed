//! # JS Loader Generator
//!
//! Generates the JavaScript loader that bridges pure FFI WASM to the DOM.
//! Since we removed wasm-bindgen, we must hand-write the imports object.
//!
//! ## Strategy
//! - Micro: Minimal loader (~500 bytes gzipped)
//! - Macro: Full HTIP loader (~1KB gzipped)

use anyhow::Result;

/// Runtime mode for loader generation
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum RuntimeMode {
    Micro,
    Macro,
}

/// Generate the JavaScript loader for the specified runtime
pub fn generate_loader(mode: RuntimeMode, verbose: bool) -> Result<String> {
    if verbose {
        println!("  ðŸ“¦ Generating {:?} loader...", mode);
    }

    let code = match mode {
        RuntimeMode::Micro => generate_micro_loader(),
        RuntimeMode::Macro => generate_macro_loader(),
    };

    if verbose {
        println!("    Generated loader: {} bytes", code.len());
    }

    Ok(code)
}

/// Generate minimal Micro loader
fn generate_micro_loader() -> String {
    r##"// dx-loader.js (Micro Mode)
// Generated by dx-compiler - DO NOT EDIT
// Runtime: 196 bytes | Loader: ~500 bytes gzipped

(function() {
  'use strict';

  // DOM node registry (WASM references nodes by u32 ID)
  const nodes = [document.body]; // ID 0 = body
  let nextId = 1;

  // Template cache
  const templates = new Map();

  // Helper: Read string from WASM memory
  const readStr = (mem, ptr, len) => {
    const bytes = new Uint8Array(mem.buffer, ptr, len);
    return new TextDecoder().decode(bytes);
  };

  // WASM imports (what Rust calls via extern "C")
  const imports = {
    env: {
      // Clone template by ID, returns node handle
      host_clone_template: (id) => {
        const tpl = templates.get(id);
        if (!tpl) {
          console.warn('Template not found:', id);
          return 0;
        }
        const clone = tpl.content.cloneNode(true).firstElementChild;
        const nodeId = nextId++;
        nodes[nodeId] = clone;
        return nodeId;
      },

      // Append child to parent
      host_append: (parentId, childId) => {
        const parent = nodes[parentId] || document.body;
        const child = nodes[childId];
        if (child) parent.appendChild(child);
      },

      // Set text content
      host_set_text: (nodeId, ptr, len) => {
        const node = nodes[nodeId];
        if (node && window.__dx_mem) {
          node.textContent = readStr(window.__dx_mem, ptr, len);
        }
      },
    }
  };

  // Load and instantiate WASM
  async function load(wasmUrl) {
    const response = await fetch(wasmUrl);
    const { instance } = await WebAssembly.instantiateStreaming(response, imports);
    
    // Store memory reference for string reading
    window.__dx_mem = instance.exports.memory;
    window.__dx = instance.exports;

    // Initialize and render
    instance.exports.init();
    instance.exports.render(0); // Render template 0
  }

  // Register template
  function registerTemplate(id, html) {
    const tpl = document.createElement('template');
    tpl.innerHTML = html;
    templates.set(id, tpl);
  }

  // Export API
  window.DX = { load, registerTemplate, nodes };
})();
"##
    .to_string()
}

/// Generate full Macro loader with HTIP support
fn generate_macro_loader() -> String {
    r##"// dx-loader.js (Macro Mode)
// Generated by dx-compiler - DO NOT EDIT
// Runtime: 1.4KB | Loader: ~1KB gzipped

(function() {
  'use strict';

  // DOM node registry
  const nodes = [document.body];
  let nextId = 1;

  // Template cache
  const templates = new Map();

  // Event handler registry
  const handlers = new Map();

  // String helper
  const readStr = (mem, ptr, len) => {
    const bytes = new Uint8Array(mem.buffer, ptr, len);
    return new TextDecoder().decode(bytes);
  };

  // WASM imports
  const imports = {
    env: {
      // Template operations
      host_clone_template: (id) => {
        const tpl = templates.get(id);
        if (!tpl) return 0;
        const clone = tpl.content.cloneNode(true).firstElementChild;
        const nodeId = nextId++;
        nodes[nodeId] = clone;
        return nodeId;
      },

      host_cache_template: (id, ptr, len) => {
        const html = readStr(window.__dx_mem, ptr, len);
        const tpl = document.createElement('template');
        tpl.innerHTML = html;
        templates.set(id, tpl);
      },

      // DOM operations
      host_append: (parentId, childId) => {
        const parent = nodes[parentId] || document.body;
        const child = nodes[childId];
        if (child) parent.appendChild(child);
      },

      host_remove: (nodeId) => {
        const node = nodes[nodeId];
        if (node && node.parentNode) {
          node.parentNode.removeChild(node);
        }
        nodes[nodeId] = null;
      },

      host_set_text: (nodeId, ptr, len) => {
        const node = nodes[nodeId];
        if (node && window.__dx_mem) {
          node.textContent = readStr(window.__dx_mem, ptr, len);
        }
      },

      host_set_attr: (nodeId, keyPtr, keyLen, valPtr, valLen) => {
        const node = nodes[nodeId];
        if (node && window.__dx_mem) {
          const key = readStr(window.__dx_mem, keyPtr, keyLen);
          const val = readStr(window.__dx_mem, valPtr, valLen);
          node.setAttribute(key, val);
        }
      },

      host_toggle_class: (nodeId, classPtr, classLen, enable) => {
        const node = nodes[nodeId];
        if (node && window.__dx_mem) {
          const className = readStr(window.__dx_mem, classPtr, classLen);
          node.classList.toggle(className, !!enable);
        }
      },

      // Events
      host_listen: (nodeId, eventType, handlerId) => {
        const node = nodes[nodeId];
        if (!node) return;

        const eventNames = ['click', 'input', 'change', 'submit', 'keydown', 'keyup'];
        const eventName = eventNames[eventType] || 'click';

        node.addEventListener(eventName, (e) => {
          e.preventDefault();
          if (window.__dx && window.__dx.on_event) {
            window.__dx.on_event(handlerId);
          }
        });
      },

      // State
      host_notify_state_change: (slotId) => {
        // Trigger re-render for slot
        console.debug('State changed:', slotId);
      },

      // Debug
      host_log: (val) => {
        console.log('[WASM]', val);
      },
    }
  };

  // Load WASM module
  async function load(wasmUrl, htipUrl) {
    const [wasmResp, htipResp] = await Promise.all([
      fetch(wasmUrl),
      htipUrl ? fetch(htipUrl) : Promise.resolve(null)
    ]);

    const { instance } = await WebAssembly.instantiateStreaming(wasmResp, imports);
    
    window.__dx_mem = instance.exports.memory;
    window.__dx = instance.exports;

    // Initialize
    instance.exports.init();

    // If HTIP stream provided, render it
    if (htipResp) {
      const htipData = new Uint8Array(await htipResp.arrayBuffer());
      const ptr = allocate(htipData.length);
      new Uint8Array(window.__dx_mem.buffer, ptr, htipData.length).set(htipData);
      instance.exports.render_stream(ptr, htipData.length);
    }
  }

  // Allocate memory in WASM heap (simple bump)
  let heapPtr = 0x10000; // Start after stack
  function allocate(size) {
    const ptr = heapPtr;
    heapPtr += size;
    return ptr;
  }

  // Register template from HTML
  function registerTemplate(id, html) {
    const tpl = document.createElement('template');
    tpl.innerHTML = html;
    templates.set(id, tpl);
  }

  // Handle events
  function on(handlerId, callback) {
    handlers.set(handlerId, callback);
  }

  // Export API
  window.DX = { load, registerTemplate, on, nodes, templates };
})();
"##
    .to_string()
}

/// Generate HTML shell with loader embedded
pub fn generate_html_shell(mode: RuntimeMode, title: &str, wasm_path: &str) -> String {
    let loader = match mode {
        RuntimeMode::Micro => generate_micro_loader(),
        RuntimeMode::Macro => generate_macro_loader(),
    };

    format!(
        r##"<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{title}</title>
  <style>
    * {{ margin: 0; padding: 0; box-sizing: border-box; }}
    body {{ font-family: system-ui, -apple-system, sans-serif; background: #0a0a0f; color: #e0e0e0; }}
    .dx-loading {{ display: flex; justify-content: center; align-items: center; min-height: 100vh; }}
  </style>
</head>
<body>
  <div class="dx-loading">Loading...</div>

  <!-- dx Template (ID: 0) -->
  <template id="dx-root">
    <div class="dx-app">
      <h1>Hello from dx-www!</h1>
      <p>Runtime: {mode:?} | WASM loaded successfully.</p>
    </div>
  </template>

  <script>
{loader}
  </script>

  <script>
    // Register template and load WASM
    DX.registerTemplate(0, document.getElementById('dx-root').innerHTML);
    DX.load('{wasm_path}').then(() => {{
      document.querySelector('.dx-loading').remove();
    }}).catch(err => {{
      console.error('DX Error:', err);
      document.querySelector('.dx-loading').textContent = 'Error loading app';
    }});
  </script>
</body>
</html>
"##,
        title = title,
        mode = mode,
        loader = loader,
        wasm_path = wasm_path
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_micro_loader() {
        let loader = generate_micro_loader();
        assert!(loader.contains("host_clone_template"));
        assert!(loader.contains("host_append"));
        assert!(loader.contains("host_set_text"));
    }

    #[test]
    fn test_generate_macro_loader() {
        let loader = generate_macro_loader();
        assert!(loader.contains("host_cache_template"));
        assert!(loader.contains("host_toggle_class"));
        assert!(loader.contains("host_listen"));
    }

    #[test]
    fn test_generate_html_shell() {
        let html = generate_html_shell(RuntimeMode::Micro, "Test App", "/app.wasm");
        assert!(html.contains("<title>Test App</title>"));
        assert!(html.contains("/app.wasm"));
    }
}
